import {
  __commonJS
} from "./chunk-EQCVQC35.js";

// node_modules/highcharts/modules/sunburst.js
var require_sunburst = __commonJS({
  "node_modules/highcharts/modules/sunburst.js"(exports, module) {
    !/**
    * Highcharts JS v12.4.0 (2025-09-04)
    * @module highcharts/modules/sunburst
    * @requires highcharts
    *
    * (c) 2016-2025 Highsoft AS
    * Authors: Jon Arild Nygard
    *
    * License: www.highcharts.com/license
    */
    function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e(t._Highcharts, t._Highcharts.Templating, t._Highcharts.Color, t._Highcharts.SeriesRegistry, t._Highcharts.SVGElement, t._Highcharts.Series) : "function" == typeof define && define.amd ? define("highcharts/modules/sunburst", ["highcharts/highcharts"], function(t2) {
        return e(t2, t2.Templating, t2.Color, t2.SeriesRegistry, t2.SVGElement, t2.Series);
      }) : "object" == typeof exports ? exports["highcharts/modules/sunburst"] = e(t._Highcharts, t._Highcharts.Templating, t._Highcharts.Color, t._Highcharts.SeriesRegistry, t._Highcharts.SVGElement, t._Highcharts.Series) : t.Highcharts = e(t.Highcharts, t.Highcharts.Templating, t.Highcharts.Color, t.Highcharts.SeriesRegistry, t.Highcharts.SVGElement, t.Highcharts.Series);
    }("undefined" == typeof window ? exports : window, (t, e, i, s, o, r) => (() => {
      "use strict";
      var a, l, n, h = { 28: (t10) => {
        t10.exports = o;
      }, 512: (t10) => {
        t10.exports = s;
      }, 620: (t10) => {
        t10.exports = i;
      }, 820: (t10) => {
        t10.exports = r;
      }, 944: (e2) => {
        e2.exports = t;
      }, 984: (t10) => {
        t10.exports = e;
      } }, d = {};
      function p(t10) {
        var e2 = d[t10];
        if (void 0 !== e2) return e2.exports;
        var i2 = d[t10] = { exports: {} };
        return h[t10](i2, i2.exports, p), i2.exports;
      }
      p.n = (t10) => {
        var e2 = t10 && t10.__esModule ? () => t10.default : () => t10;
        return p.d(e2, { a: e2 }), e2;
      }, p.d = (t10, e2) => {
        for (var i2 in e2) p.o(e2, i2) && !p.o(t10, i2) && Object.defineProperty(t10, i2, { enumerable: true, get: e2[i2] });
      }, p.o = (t10, e2) => Object.prototype.hasOwnProperty.call(t10, e2);
      var u = {};
      p.d(u, { default: () => eS });
      var c = p(944), g = p.n(c);
      let v = { lang: { mainBreadcrumb: "Main" }, options: { buttonTheme: { fill: "none", height: 18, padding: 2, "stroke-width": 0, zIndex: 7, states: { select: { fill: "none" } }, style: { color: "#334eff" } }, buttonSpacing: 5, floating: false, format: void 0, relativeTo: "plotBox", rtl: false, position: { align: "left", verticalAlign: "top", x: 0, y: void 0 }, separator: { text: "/", style: { color: "#666666", fontSize: "0.8em" } }, showFullPath: true, style: {}, useHTML: false, zIndex: 7 } };
      var f = p(984);
      let { format: b } = p.n(f)(), { composed: m } = g(), { addEvent: x, defined: y, extend: L, fireEvent: P, isString: T, merge: w, objectEach: A, pick: R, pushUnique: S } = g();
      function O() {
        if (this.breadcrumbs) {
          let t10 = this.resetZoomButton && this.resetZoomButton.getBBox(), e2 = this.breadcrumbs.options;
          t10 && "right" === e2.position.align && "plotBox" === e2.relativeTo && this.breadcrumbs.alignBreadcrumbsGroup(-t10.width - e2.buttonSpacing);
        }
      }
      function C() {
        this.breadcrumbs && (this.breadcrumbs.destroy(), this.breadcrumbs = void 0);
      }
      function M() {
        let t10 = this.breadcrumbs;
        if (t10 && !t10.options.floating && t10.level) {
          let e2 = t10.options, i2 = e2.buttonTheme, s2 = (i2.height || 0) + 2 * (i2.padding || 0) + e2.buttonSpacing, o2 = e2.position.verticalAlign;
          "bottom" === o2 ? (this.marginBottom = (this.marginBottom || 0) + s2, t10.yOffset = s2) : "middle" !== o2 ? (this.plotTop += s2, t10.yOffset = -s2) : t10.yOffset = void 0;
        }
      }
      function B() {
        this.breadcrumbs && this.breadcrumbs.redraw();
      }
      function I(t10) {
        true === t10.resetSelection && this.breadcrumbs && this.breadcrumbs.alignBreadcrumbsGroup();
      }
      class N {
        static compose(t10, e2) {
          S(m, "Breadcrumbs") && (x(t10, "destroy", C), x(t10, "afterShowResetZoom", O), x(t10, "getMargins", M), x(t10, "redraw", B), x(t10, "selection", I), L(e2.lang, v.lang));
        }
        constructor(t10, e2) {
          this.elementList = {}, this.isDirty = true, this.level = 0, this.list = [];
          let i2 = w(t10.options.drilldown && t10.options.drilldown.drillUpButton, N.defaultOptions, t10.options.navigation && t10.options.navigation.breadcrumbs, e2);
          this.chart = t10, this.options = i2 || {};
        }
        updateProperties(t10) {
          this.setList(t10), this.setLevel(), this.isDirty = true;
        }
        setList(t10) {
          this.list = t10;
        }
        setLevel() {
          this.level = this.list.length && this.list.length - 1;
        }
        getLevel() {
          return this.level;
        }
        getButtonText(t10) {
          let e2 = this.chart, i2 = this.options, s2 = e2.options.lang, o2 = R(i2.format, i2.showFullPath ? "{level.name}" : "← {level.name}"), r2 = s2 && R(s2.drillUpText, s2.mainBreadcrumb), a2 = i2.formatter && i2.formatter(t10) || b(o2, { level: t10.levelOptions }, e2) || "";
          return (T(a2) && !a2.length || "← " === a2) && y(r2) && (a2 = i2.showFullPath ? r2 : "← " + r2), a2;
        }
        redraw() {
          this.isDirty && this.render(), this.group && this.group.align(), this.isDirty = false;
        }
        render() {
          let t10 = this.chart, e2 = this.options;
          !this.group && e2 && (this.group = t10.renderer.g("breadcrumbs-group").addClass("highcharts-no-tooltip highcharts-breadcrumbs").attr({ zIndex: e2.zIndex }).add()), e2.showFullPath ? this.renderFullPathButtons() : this.renderSingleButton(), this.alignBreadcrumbsGroup();
        }
        renderFullPathButtons() {
          this.destroySingleButton(), this.resetElementListState(), this.updateListElements(), this.destroyListElements();
        }
        renderSingleButton() {
          let t10 = this.chart, e2 = this.list, i2 = this.options.buttonSpacing;
          this.destroyListElements();
          let s2 = this.group ? this.group.getBBox().width : i2, o2 = e2[e2.length - 2];
          !t10.drillUpButton && this.level > 0 ? t10.drillUpButton = this.renderButton(o2, s2, i2) : t10.drillUpButton && (this.level > 0 ? this.updateSingleButton() : this.destroySingleButton());
        }
        alignBreadcrumbsGroup(t10) {
          if (this.group) {
            let e2 = this.options, i2 = e2.buttonTheme, s2 = e2.position, o2 = "chart" === e2.relativeTo || "spacingBox" === e2.relativeTo ? void 0 : "plotBox", r2 = this.group.getBBox(), a2 = 2 * (i2.padding || 0) + e2.buttonSpacing;
            s2.width = r2.width + a2, s2.height = r2.height + a2;
            let l2 = w(s2);
            t10 && (l2.x += t10), this.options.rtl && (l2.x += s2.width), l2.y = R(l2.y, this.yOffset, 0), this.group.align(l2, true, o2);
          }
        }
        renderButton(t10, e2, i2) {
          let s2 = this, o2 = this.chart, r2 = s2.options, a2 = w(r2.buttonTheme), l2 = o2.renderer.button(s2.getButtonText(t10), e2, i2, function(e3) {
            let i3, o3 = r2.events && r2.events.click;
            o3 && (i3 = o3.call(s2, e3, t10)), false !== i3 && (r2.showFullPath ? e3.newLevel = t10.level : e3.newLevel = s2.level - 1, P(s2, "up", e3));
          }, a2).addClass("highcharts-breadcrumbs-button").add(s2.group);
          return o2.styledMode || l2.attr(r2.style), l2;
        }
        renderSeparator(t10, e2) {
          let i2 = this.chart, s2 = this.options.separator, o2 = i2.renderer.label(s2.text, t10, e2, void 0, void 0, void 0, false).addClass("highcharts-breadcrumbs-separator").add(this.group);
          return i2.styledMode || o2.css(s2.style), o2;
        }
        update(t10) {
          w(true, this.options, t10), this.destroy(), this.isDirty = true;
        }
        updateSingleButton() {
          let t10 = this.chart, e2 = this.list[this.level - 1];
          t10.drillUpButton && t10.drillUpButton.attr({ text: this.getButtonText(e2) });
        }
        destroy() {
          this.destroySingleButton(), this.destroyListElements(true), this.group && this.group.destroy(), this.group = void 0;
        }
        destroyListElements(t10) {
          let e2 = this.elementList;
          A(e2, (i2, s2) => {
            (t10 || !e2[s2].updated) && ((i2 = e2[s2]).button && i2.button.destroy(), i2.separator && i2.separator.destroy(), delete i2.button, delete i2.separator, delete e2[s2]);
          }), t10 && (this.elementList = {});
        }
        destroySingleButton() {
          this.chart.drillUpButton && (this.chart.drillUpButton.destroy(), this.chart.drillUpButton = void 0);
        }
        resetElementListState() {
          A(this.elementList, (t10) => {
            t10.updated = false;
          });
        }
        updateListElements() {
          let t10 = this.elementList, e2 = this.options.buttonSpacing, i2 = this.list, s2 = this.options.rtl, o2 = s2 ? -1 : 1, r2 = function(t11, e3) {
            return o2 * t11.getBBox().width + o2 * e3;
          }, a2 = function(t11, e3, i3) {
            t11.translate(e3 - t11.getBBox().width, i3);
          }, l2 = this.group ? r2(this.group, e2) : e2, n2, h2;
          for (let d2 = 0, p2 = i2.length; d2 < p2; ++d2) {
            let u2, c2, g2 = d2 === p2 - 1;
            t10[(h2 = i2[d2]).level] ? (u2 = (n2 = t10[h2.level]).button, n2.separator || g2 ? n2.separator && g2 && (n2.separator.destroy(), delete n2.separator) : (l2 += o2 * e2, n2.separator = this.renderSeparator(l2, e2), s2 && a2(n2.separator, l2, e2), l2 += r2(n2.separator, e2)), t10[h2.level].updated = true) : (u2 = this.renderButton(h2, l2, e2), s2 && a2(u2, l2, e2), l2 += r2(u2, e2), g2 || (c2 = this.renderSeparator(l2, e2), s2 && a2(c2, l2, e2), l2 += r2(c2, e2)), t10[h2.level] = { button: u2, separator: c2, updated: true }), u2 && u2.setState(2 * !!g2);
          }
        }
      }
      N.defaultOptions = v.options;
      var D = p(620), E = p.n(D), H = p(512), G = p.n(H), k = p(28), V = p.n(k);
      let { column: { prototype: z } } = G().seriesTypes, { addEvent: W, defined: U } = g();
      !function(t10) {
        function e2(t11) {
          let e3 = this.series, i2 = e3.chart.renderer;
          this.moveToTopOnHover && this.graphic && (e3.stateMarkerGraphic || (e3.stateMarkerGraphic = new (V())(i2, "use").css({ pointerEvents: "none" }).add(this.graphic.parentGroup)), (t11 == null ? void 0 : t11.state) === "hover" ? (this.graphic.attr({ id: this.id }), e3.stateMarkerGraphic.attr({ href: `${i2.url}#${this.id}`, visibility: "visible" })) : e3.stateMarkerGraphic.attr({ href: "" }));
        }
        t10.pointMembers = { dataLabelOnNull: true, moveToTopOnHover: true, isValid: function() {
          return null !== this.value && this.value !== 1 / 0 && this.value !== -1 / 0 && (void 0 === this.value || !isNaN(this.value));
        } }, t10.seriesMembers = { colorKey: "value", axisTypes: ["xAxis", "yAxis", "colorAxis"], parallelArrays: ["x", "y", "value"], pointArrayMap: ["value"], trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], colorAttribs: function(t11) {
          let e3 = {};
          return U(t11.color) && (!t11.state || "normal" === t11.state) && (e3[this.colorProp || "fill"] = t11.color), e3;
        }, pointAttribs: z.pointAttribs }, t10.compose = function(t11) {
          return W(t11.prototype.pointClass, "afterSetState", e2), t11;
        };
      }(a || (a = {}));
      let F = a;
      var _ = p(820), Y = p.n(_);
      let j = class {
        constructor(t10, e2, i2, s2) {
          this.height = t10, this.width = e2, this.plot = s2, this.direction = i2, this.startDirection = i2, this.total = 0, this.nW = 0, this.lW = 0, this.nH = 0, this.lH = 0, this.elArr = [], this.lP = { total: 0, lH: 0, nH: 0, lW: 0, nW: 0, nR: 0, lR: 0, aspectRatio: function(t11, e3) {
            return Math.max(t11 / e3, e3 / t11);
          } };
        }
        addElement(t10) {
          this.lP.total = this.elArr[this.elArr.length - 1], this.total = this.total + t10, 0 === this.direction ? (this.lW = this.nW, this.lP.lH = this.lP.total / this.lW, this.lP.lR = this.lP.aspectRatio(this.lW, this.lP.lH), this.nW = this.total / this.height, this.lP.nH = this.lP.total / this.nW, this.lP.nR = this.lP.aspectRatio(this.nW, this.lP.nH)) : (this.lH = this.nH, this.lP.lW = this.lP.total / this.lH, this.lP.lR = this.lP.aspectRatio(this.lP.lW, this.lH), this.nH = this.total / this.width, this.lP.nW = this.lP.total / this.nH, this.lP.nR = this.lP.aspectRatio(this.lP.nW, this.nH)), this.elArr.push(t10);
        }
        reset() {
          this.nW = 0, this.lW = 0, this.elArr = [], this.total = 0;
        }
      }, X = class {
        constructor() {
          this.childrenTotal = 0, this.visible = false;
        }
        init(t10, e2, i2, s2, o2, r2, a2) {
          return this.id = t10, this.i = e2, this.children = i2, this.height = s2, this.level = o2, this.series = r2, this.parent = a2, this;
        }
      }, $ = { draw: function(t10, e2) {
        let { animatableAttribs: i2, onComplete: s2, css: o2, renderer: r2 } = e2, a2 = t10.series && t10.series.chart.hasRendered ? void 0 : t10.series && t10.series.options.animation, l2 = t10.graphic;
        if (e2.attribs = { ...e2.attribs, class: t10.getClassName() }, t10.shouldDraw()) l2 || (t10.graphic = l2 = "text" === e2.shapeType ? r2.text() : "image" === e2.shapeType ? r2.image(e2.imageUrl || "").attr(e2.shapeArgs || {}) : r2[e2.shapeType](e2.shapeArgs || {}), l2.add(e2.group)), o2 && l2.css(o2), l2.attr(e2.attribs).animate(i2, !e2.isNew && a2, s2);
        else if (l2) {
          let e3 = () => {
            t10.graphic = l2 = l2 && l2.destroy(), "function" == typeof s2 && s2();
          };
          Object.keys(i2).length ? l2.animate(i2, void 0, () => e3()) : e3();
        }
      } }, { pie: { prototype: { pointClass: K } }, scatter: { prototype: { pointClass: q } } } = G().seriesTypes, { extend: Z, isNumber: J, pick: Q } = g();
      class tt extends q {
        constructor() {
          super(...arguments), this.groupedPointsAmount = 0, this.shapeType = "rect";
        }
        draw(t10) {
          $.draw(this, t10);
        }
        getClassName() {
          let t10 = this.series, e2 = t10.options, i2 = super.getClassName();
          return this.node.level <= t10.nodeMap[t10.rootNode].level && this.node.children.length ? i2 += " highcharts-above-level" : this.node.isGroup || this.node.isLeaf || t10.nodeMap[t10.rootNode].isGroup || Q(e2.interactByLeaf, !e2.allowTraversingTree) ? this.node.isGroup || this.node.isLeaf || t10.nodeMap[t10.rootNode].isGroup || (i2 += " highcharts-internal-node") : i2 += " highcharts-internal-node-interactive", i2;
        }
        isValid() {
          return !!(this.id || J(this.value));
        }
        setState(t10) {
          super.setState.apply(this, arguments), this.graphic && this.graphic.attr({ zIndex: +("hover" === t10) });
        }
        shouldDraw() {
          return J(this.plotY) && null !== this.y;
        }
      }
      Z(tt.prototype, { setVisible: K.prototype.setVisible });
      let { isString: te } = g(), ti = { allowTraversingTree: false, animationLimit: 250, borderRadius: 0, showInLegend: false, marker: void 0, colorByPoint: false, dataLabels: { enabled: true, formatter: function() {
        let t10 = this && this.point ? this.point : {};
        return te(t10.name) ? t10.name : "";
      }, headers: false, inside: true, padding: 2, verticalAlign: "middle", style: { textOverflow: "ellipsis" } }, tooltip: { headerFormat: "", pointFormat: "<b>{point.name}</b>: {point.value}<br/>", clusterFormat: "+ {point.groupedPointsAmount} more...<br/>" }, ignoreHiddenPoint: true, layoutAlgorithm: "sliceAndDice", layoutStartingDirection: "vertical", alternateStartingDirection: false, levelIsConstant: true, traverseUpButton: { position: { align: "right", x: -10, y: 10 } }, borderColor: "#e6e6e6", borderWidth: 1, colorKey: "colorValue", opacity: 0.15, states: { hover: { borderColor: "#999999", brightness: 0.1 * !G().seriesTypes.heatmap, halo: false, opacity: 0.75, shadow: false } }, legendSymbol: "rectangle", traverseToLeaf: false, cluster: { className: void 0, color: void 0, enabled: false, pixelWidth: void 0, pixelHeight: void 0, name: void 0, reductionFactor: void 0, minimumClusterSize: 5, layoutAlgorithm: { distance: 0, gridSize: 0, kmeansThreshold: 0 }, marker: { lineWidth: 0, radius: 0 } } };
      (l || (l = {})).recursive = function t10(e2, i2, s2) {
        let o2 = i2.call(s2 || this, e2);
        false !== o2 && t10(o2, i2, s2);
      };
      let ts = l, { extend: to, isArray: tr, isNumber: ta, isObject: tl, merge: tn, pick: th, relativeLength: td } = g(), tp = { getColor: function(t10, e2) {
        let i2, s2, o2, r2, a2, l2, n2 = e2.index, h2 = e2.mapOptionsToLevel, d2 = e2.parentColor, p2 = e2.parentColorIndex, u2 = e2.series, c2 = e2.colors, g2 = e2.siblings, v2 = u2.points, f2 = u2.chart.options.chart;
        return t10 && (i2 = v2[t10.i], s2 = h2[t10.level] || {}, i2 && s2.colorByPoint && (r2 = i2.index % (c2 ? c2.length : f2.colorCount), o2 = c2 && c2[r2]), u2.chart.styledMode || (a2 = th(i2 && i2.options.color, s2 && s2.color, o2, d2 && ((t11) => {
          let e3 = s2 && s2.colorVariation;
          return e3 && "brightness" === e3.key && n2 && g2 ? E().parse(t11).brighten(e3.to * (n2 / g2)).get() : t11;
        })(d2), u2.color)), l2 = th(i2 && i2.options.colorIndex, s2 && s2.colorIndex, r2, p2, e2.colorIndex)), { color: a2, colorIndex: l2 };
      }, getLevelOptions: function(t10) {
        let e2, i2, s2, o2, r2, a2, l2 = {};
        if (tl(t10)) for (o2 = ta(t10.from) ? t10.from : 1, a2 = t10.levels, i2 = {}, e2 = tl(t10.defaults) ? t10.defaults : {}, tr(a2) && (i2 = a2.reduce((t11, i3) => {
          let s3, r3, a3;
          return tl(i3) && ta(i3.level) && (r3 = th((a3 = tn({}, i3)).levelIsConstant, e2.levelIsConstant), delete a3.levelIsConstant, delete a3.level, tl(t11[s3 = i3.level + (r3 ? 0 : o2 - 1)]) ? tn(true, t11[s3], a3) : t11[s3] = a3), t11;
        }, {})), r2 = ta(t10.to) ? t10.to : 1, s2 = 0; s2 <= r2; s2++) l2[s2] = tn({}, e2, tl(i2[s2]) ? i2[s2] : {});
        return l2;
      }, getNodeWidth: function(t10, e2) {
        let { chart: i2, options: s2 } = t10, { nodeDistance: o2 = 0, nodeWidth: r2 = 0 } = s2, { plotSizeX: a2 = 1 } = i2;
        if ("auto" === r2) {
          if ("string" == typeof o2 && /%$/.test(o2)) return a2 / (e2 + parseFloat(o2) / 100 * (e2 - 1));
          let t11 = Number(o2);
          return (a2 + t11) / (e2 || 1) - t11;
        }
        return td(r2, a2);
      }, setTreeValues: function t10(e2, i2) {
        let s2 = i2.before, o2 = i2.idRoot, r2 = i2.mapIdToNode[o2], a2 = false !== i2.levelIsConstant, l2 = i2.points[e2.i], n2 = l2 && l2.options || {}, h2 = [], d2 = 0;
        e2.levelDynamic = e2.level - (a2 ? 0 : r2.level), e2.name = th(l2 && l2.name, ""), e2.visible = o2 === e2.id || true === i2.visible, "function" == typeof s2 && (e2 = s2(e2, i2)), e2.children.forEach((s3, o3) => {
          let r3 = to({}, i2);
          to(r3, { index: o3, siblings: e2.children.length, visible: e2.visible }), s3 = t10(s3, r3), h2.push(s3), s3.visible && (d2 += s3.val);
        });
        let p2 = th(n2.value, d2);
        return e2.visible = p2 >= 0 && (d2 > 0 || e2.visible), e2.children = h2, e2.childrenTotal = d2, e2.isLeaf = e2.visible && !d2, e2.val = p2, e2;
      }, updateRootId: function(t10) {
        let e2, i2;
        return tl(t10) && (i2 = tl(t10.options) ? t10.options : {}, e2 = th(t10.rootNode, i2.rootId, ""), tl(t10.userOptions) && (t10.userOptions.rootId = e2), t10.rootNode = e2), e2;
      } }, { parse: tu } = E(), { composed: tc, noop: tg } = g(), { column: tv, scatter: tf } = G().seriesTypes, { getColor: tb, getLevelOptions: tm, updateRootId: tx } = tp, { addEvent: ty, arrayMax: tL, clamp: tP, correctFloat: tT, crisp: tw, defined: tA, error: tR, extend: tS, fireEvent: tO, isArray: tC, isNumber: tM, isObject: tB, isString: tI, merge: tN, pick: tD, pushUnique: tE, splat: tH, stableSort: tG } = g();
      Y().keepProps.push("simulation", "hadOutsideDataLabels");
      let tk = false;
      function tV() {
        let t10, e2 = this.xAxis, i2 = this.yAxis;
        e2 && i2 && (this.is("treemap") ? (t10 = { endOnTick: false, gridLineWidth: 0, lineWidth: 0, min: 0, minPadding: 0, max: 100, maxPadding: 0, startOnTick: false, title: void 0, tickPositions: [] }, tS(i2.options, t10), tS(e2.options, t10), tk = true) : tk && (i2.setOptions(i2.userOptions), e2.setOptions(e2.userOptions), tk = false));
      }
      class tz extends tf {
        constructor() {
          super(...arguments), this.simulation = 0;
        }
        static compose(t10) {
          tE(tc, "TreemapSeries") && ty(t10, "afterBindAxes", tV);
        }
        algorithmCalcPoints(t10, e2, i2, s2) {
          let o2 = i2.plot, r2 = i2.elArr.length - 1, a2, l2, n2, h2, d2 = i2.lW, p2 = i2.lH, u2, c2 = 0;
          for (let t11 of (e2 ? (d2 = i2.nW, p2 = i2.nH) : u2 = i2.elArr[r2], i2.elArr)) (e2 || c2 < r2) && (0 === i2.direction ? (a2 = o2.x, l2 = o2.y, h2 = t11 / (n2 = d2)) : (a2 = o2.x, l2 = o2.y, n2 = t11 / (h2 = p2)), s2.push({ x: a2, y: l2, width: n2, height: tT(h2) }), 0 === i2.direction ? o2.y = o2.y + h2 : o2.x = o2.x + n2), c2 += 1;
          i2.reset(), 0 === i2.direction ? i2.width = i2.width - d2 : i2.height = i2.height - p2, o2.y = o2.parent.y + (o2.parent.height - i2.height), o2.x = o2.parent.x + (o2.parent.width - i2.width), t10 && (i2.direction = 1 - i2.direction), e2 || i2.addElement(u2);
        }
        algorithmFill(t10, e2, i2) {
          let s2 = [], o2, r2 = e2.direction, a2 = e2.x, l2 = e2.y, n2 = e2.width, h2 = e2.height, d2, p2, u2, c2;
          for (let g2 of i2) o2 = e2.width * e2.height * (g2.val / e2.val), d2 = a2, p2 = l2, 0 === r2 ? (n2 -= u2 = o2 / (c2 = h2), a2 += u2) : (h2 -= c2 = o2 / (u2 = n2), l2 += c2), s2.push({ x: d2, y: p2, width: u2, height: c2, direction: 0, val: 0 }), t10 && (r2 = 1 - r2);
          return s2;
        }
        algorithmLowAspectRatio(t10, e2, i2) {
          let s2 = [], o2 = { x: e2.x, y: e2.y, parent: e2 }, r2 = e2.direction, a2 = i2.length - 1, l2 = new j(e2.height, e2.width, r2, o2), n2, h2 = 0;
          for (let r3 of i2) n2 = e2.width * e2.height * (r3.val / e2.val), l2.addElement(n2), l2.lP.nR > l2.lP.lR && this.algorithmCalcPoints(t10, false, l2, s2, o2), h2 === a2 && this.algorithmCalcPoints(t10, true, l2, s2, o2), ++h2;
          return s2;
        }
        alignDataLabel(t10, e2, i2) {
          tv.prototype.alignDataLabel.apply(this, arguments), t10.dataLabel && t10.dataLabel.attr({ zIndex: (t10.node.zIndex || 0) + 1 });
        }
        applyTreeGrouping() {
          let t10 = this, e2 = t10.parentList || {}, { cluster: i2 } = t10.options, s2 = (i2 == null ? void 0 : i2.minimumClusterSize) || 5;
          if (i2 == null ? void 0 : i2.enabled) {
            let o2 = {}, r2 = (t11) => {
              var _a;
              if ((_a = t11 == null ? void 0 : t11.point) == null ? void 0 : _a.shapeArgs) {
                let { width: e3 = 0, height: s3 = 0 } = t11.point.shapeArgs, { pixelWidth: r3 = 0, pixelHeight: a3 = 0 } = i2, l2 = tA(a3), n2 = a3 ? r3 * a3 : r3 * r3;
                (e3 < r3 || s3 < (l2 ? a3 : r3) || e3 * s3 < n2) && !t11.isGroup && tA(t11.parent) && (o2[t11.parent] || (o2[t11.parent] = []), o2[t11.parent].push(t11));
              }
              t11 == null ? void 0 : t11.children.forEach((t12) => {
                r2(t12);
              });
            };
            for (let a3 in r2(t10.tree), o2) o2[a3] && o2[a3].length > s2 && o2[a3].forEach((s3) => {
              let o3 = e2[a3].indexOf(s3.i);
              if (-1 !== o3) {
                e2[a3].splice(o3, 1);
                let r3 = `highcharts-grouped-treemap-points-${s3.parent || "root"}`, l2 = t10.points.find((t11) => t11.id === r3);
                if (!l2) {
                  let s4 = t10.pointClass, o4 = t10.points.length;
                  tS(l2 = new s4(t10, { className: i2.className, color: i2.color, id: r3, index: o4, isGroup: true, value: 0 }), { formatPrefix: "cluster" }), t10.points.push(l2), e2[a3].push(o4), e2[r3] = [];
                }
                let n2 = l2.groupedPointsAmount + 1, h2 = t10.points[l2.index].options.value || 0, d2 = i2.name || `+ ${n2}`;
                t10.points[l2.index].groupedPointsAmount = n2, t10.points[l2.index].options.value = h2 + (s3.point.value || 0), t10.points[l2.index].name = d2, e2[r3].push(s3.point.index);
              }
            });
            t10.nodeMap = {}, t10.nodeList = [], t10.parentList = e2;
            let a2 = t10.buildTree("", -1, 0, t10.parentList);
            t10.translate(a2);
          }
        }
        calculateChildrenAreas(t10, e2) {
          var _a, _b, _c, _d;
          let i2 = this.options, s2 = this.mapOptionsToLevel[t10.level + 1], o2 = tD((s2 == null ? void 0 : s2.layoutAlgorithm) && this[s2 == null ? void 0 : s2.layoutAlgorithm] && s2.layoutAlgorithm, i2.layoutAlgorithm), r2 = i2.alternateStartingDirection, a2 = t10.children.filter((e3) => t10.isGroup || !e3.ignore), l2 = (s2 == null ? void 0 : s2.groupPadding) ?? i2.groupPadding ?? 0, n2 = this.nodeMap[this.rootNode];
          if (!o2) return;
          let h2 = [], d2 = ((_a = n2.pointValues) == null ? void 0 : _a.width) || 0, p2 = ((_b = n2.pointValues) == null ? void 0 : _b.height) || 0;
          (s2 == null ? void 0 : s2.layoutStartingDirection) && (e2.direction = +("vertical" !== s2.layoutStartingDirection)), h2 = this[o2](e2, a2);
          let u2 = -1;
          for (let t11 of a2) {
            let i3 = h2[++u2];
            t11 === n2 && (d2 = d2 || i3.width, p2 = i3.height);
            let s3 = l2 / (this.xAxis.len / p2), o3 = l2 / (this.yAxis.len / p2);
            if (t11.values = tN(i3, { val: t11.childrenTotal, direction: r2 ? 1 - e2.direction : e2.direction }), t11.children.length && ((_c = t11.point.dataLabels) == null ? void 0 : _c.length)) {
              let e3 = tL(t11.point.dataLabels.map((t12) => {
                var _a2;
                return ((_a2 = t12.options) == null ? void 0 : _a2.headers) && t12.height || 0;
              })) / (this.yAxis.len / p2);
              e3 < t11.values.height / 2 && (t11.values.y += e3, t11.values.height -= e3);
            }
            if (l2) {
              let e3 = Math.min(s3, t11.values.width / 4), i4 = Math.min(o3, t11.values.height / 4);
              t11.values.x += e3, t11.values.width -= 2 * e3, t11.values.y += i4, t11.values.height -= 2 * i4;
            }
            t11.pointValues = tN(i3, { x: i3.x / this.axisRatio, y: 100 - i3.y - i3.height, width: i3.width / this.axisRatio }), t11.children.length && this.calculateChildrenAreas(t11, t11.values);
          }
          let c2 = (t11, e3 = [], i3 = true) => (t11.children.forEach((t12) => {
            i3 && t12.isLeaf ? e3.push(t12.point) : i3 || t12.isLeaf || e3.push(t12.point), t12.children.length && c2(t12, e3, i3);
          }), e3);
          if ("leaf" === i2.nodeSizeBy && t10 === n2 && this.hasOutsideDataLabels && !c2(n2, void 0, false).some((t11) => tM(t11.options.value)) && !tM((_d = n2.point) == null ? void 0 : _d.options.value)) {
            let i3 = c2(n2), s3 = i3.map((t11) => t11.options.value || 0), o3 = i3.map(({ node: { pointValues: t11 } }) => t11 ? t11.width * t11.height : 0), r3 = s3.reduce((t11, e3) => t11 + e3, 0), a3 = o3.reduce((t11, e3) => t11 + e3, 0) / r3, l3 = 0, h3 = 0;
            i3.forEach((t11, e3) => {
              let i4 = tP((s3[e3] ? o3[e3] / s3[e3] : 1) / a3, 0.8, 1.4), r4 = 1 - i4;
              t11.value && (o3[e3] < 20 && (r4 *= o3[e3] / 20), r4 > h3 && (h3 = r4), r4 < l3 && (l3 = r4), t11.simulatedValue = (t11.simulatedValue || t11.value) / i4);
            }), (l3 < -0.05 || h3 > 0.05) && this.simulation < 10 ? (this.simulation++, this.setTreeValues(t10), e2.val = t10.val, this.calculateChildrenAreas(t10, e2)) : (i3.forEach((t11) => {
              delete t11.simulatedValue;
            }), this.setTreeValues(t10), this.simulation = 0);
          }
        }
        createList(t10) {
          let e2 = this.chart, i2 = e2.breadcrumbs, s2 = [];
          if (i2) {
            let i3 = 0;
            s2.push({ level: i3, levelOptions: e2.series[0] });
            let o2 = t10.target.nodeMap[t10.newRootId], r2 = [];
            for (; o2.parent || "" === o2.parent; ) r2.push(o2), o2 = t10.target.nodeMap[o2.parent];
            for (let t11 of r2.reverse()) s2.push({ level: ++i3, levelOptions: t11 });
            s2.length <= 1 && (s2.length = 0);
          }
          return s2;
        }
        drawDataLabels() {
          var _a, _b;
          let t10 = this.mapOptionsToLevel, e2 = this.points.filter(function(t11) {
            return t11.node.visible || tA(t11.dataLabel);
          }), i2 = (_a = tH(this.options.dataLabels || {})[0]) == null ? void 0 : _a.padding, s2 = e2.some((t11) => tM(t11.plotY));
          for (let o2 of e2) {
            let e3 = {}, r2 = { style: e3 }, a2 = t10[o2.node.level];
            if ((!o2.node.isLeaf && !o2.node.isGroup || o2.node.isGroup && o2.node.level <= this.nodeMap[this.rootNode].level) && (r2.enabled = false), (a2 == null ? void 0 : a2.dataLabels) && (tN(true, r2, tH(a2.dataLabels)[0]), this.hasDataLabels = () => true), o2.node.isLeaf ? r2.inside = true : r2.headers && (r2.verticalAlign = "top"), o2.shapeArgs && s2) {
              let { height: t11 = 0, width: s3 = 0 } = o2.shapeArgs;
              if (s3 > 32 && t11 > 16 && o2.shouldDraw()) {
                let a3 = s3 - 2 * (r2.padding || i2 || 0);
                e3.width = `${a3}px`, e3.lineClamp ?? (e3.lineClamp = Math.floor(t11 / 16)), e3.visibility = "inherit", r2.headers && ((_b = o2.dataLabel) == null ? void 0 : _b.attr({ width: a3 }));
              } else e3.width = `${s3}px`, e3.visibility = "hidden";
            }
            o2.dlOptions = tN(r2, o2.options.dataLabels);
          }
          super.drawDataLabels(e2);
        }
        drawPoints(t10 = this.points) {
          let e2 = this.chart, i2 = e2.renderer, s2 = e2.styledMode, o2 = this.options, r2 = s2 ? {} : o2.shadow, a2 = o2.borderRadius, l2 = e2.pointCount < o2.animationLimit, n2 = o2.allowTraversingTree;
          for (let e3 of t10) {
            let t11 = {}, h2 = {}, d2 = {}, p2 = "level-group-" + e3.node.level, u2 = !!e3.graphic, c2 = l2 && u2, g2 = e3.shapeArgs;
            e3.shouldDraw() && (e3.isInside = true, a2 && (h2.r = a2), tN(true, c2 ? t11 : h2, u2 ? g2 : {}, s2 ? {} : this.pointAttribs(e3, e3.selected ? "select" : void 0)), this.colorAttribs && s2 && tS(d2, this.colorAttribs(e3)), this[p2] || (this[p2] = i2.g(p2).attr({ zIndex: -(e3.node.level || 0) }).add(this.group), this[p2].survive = true)), e3.draw({ animatableAttribs: t11, attribs: h2, css: d2, group: this[p2], imageUrl: e3.imageUrl, renderer: i2, shadow: r2, shapeArgs: g2, shapeType: e3.shapeType }), n2 && e3.graphic && (e3.drillId = o2.interactByLeaf ? this.drillToByLeaf(e3) : this.drillToByGroup(e3));
          }
        }
        drillToByGroup(t10) {
          return (!t10.node.isLeaf || !!t10.node.isGroup) && t10.id;
        }
        drillToByLeaf(t10) {
          let { traverseToLeaf: e2 } = t10.series.options, i2 = false, s2;
          if (t10.node.parent !== this.rootNode && t10.node.isLeaf) if (e2) i2 = t10.id;
          else for (s2 = t10.node; !i2; ) void 0 !== s2.parent && (s2 = this.nodeMap[s2.parent]), s2.parent === this.rootNode && (i2 = s2.id);
          return i2;
        }
        drillToNode(t10, e2) {
          tR(32, false, void 0, { "treemap.drillToNode": "use treemap.setRootNode" }), this.setRootNode(t10, e2);
        }
        drillUp() {
          let t10 = this.nodeMap[this.rootNode];
          t10 && tI(t10.parent) && this.setRootNode(t10.parent, true, { trigger: "traverseUpButton" });
        }
        getExtremes() {
          let { dataMin: t10, dataMax: e2 } = super.getExtremes(this.colorValueData);
          return this.valueMin = t10, this.valueMax = e2, super.getExtremes();
        }
        getListOfParents(t10, e2) {
          let i2 = tC(t10) ? t10 : [], s2 = tC(e2) ? e2 : [], o2 = i2.reduce(function(t11, e3, i3) {
            let s3 = tD(e3.parent, "");
            return void 0 === t11[s3] && (t11[s3] = []), t11[s3].push(i3), t11;
          }, { "": [] });
          for (let t11 of Object.keys(o2)) {
            let e3 = o2[t11];
            if ("" !== t11 && -1 === s2.indexOf(t11)) {
              for (let t12 of e3) o2[""].push(t12);
              delete o2[t11];
            }
          }
          return o2;
        }
        getTree() {
          let t10 = this.data.map(function(t11) {
            return t11.id;
          });
          return this.parentList = this.getListOfParents(this.data, t10), this.nodeMap = {}, this.nodeList = [], this.buildTree("", -1, 0, this.parentList || {});
        }
        buildTree(t10, e2, i2, s2, o2) {
          let r2 = [], a2 = this.points[e2], l2 = 0, n2;
          for (let e3 of s2[t10] || []) l2 = Math.max((n2 = this.buildTree(this.points[e3].id, e3, i2 + 1, s2, t10)).height + 1, l2), r2.push(n2);
          let h2 = new this.NodeClass().init(t10, e2, r2, l2, i2, this, o2);
          for (let t11 of r2) t11.parentNode = h2;
          return this.nodeMap[h2.id] = h2, this.nodeList.push(h2), a2 && (a2.node = h2, h2.point = a2), h2;
        }
        hasData() {
          return !!this.dataTable.rowCount;
        }
        init(t10, e2) {
          let i2 = this, s2 = tN(e2.drillUpButton, e2.breadcrumbs), o2 = ty(i2, "setOptions", (t11) => {
            var _a;
            let e3 = t11.userOptions;
            tA(e3.allowDrillToNode) && !tA(e3.allowTraversingTree) && (e3.allowTraversingTree = e3.allowDrillToNode, delete e3.allowDrillToNode), tA(e3.drillUpButton) && !tA(e3.traverseUpButton) && (e3.traverseUpButton = e3.drillUpButton, delete e3.drillUpButton);
            let i3 = tH(e3.dataLabels || {});
            (_a = e3.levels) == null ? void 0 : _a.forEach((t12) => {
              i3.push.apply(i3, tH(t12.dataLabels || {}));
            }), this.hasOutsideDataLabels = i3.some((t12) => t12.headers);
          });
          super.init(t10, e2), delete i2.opacity, i2.eventsToUnbind.push(o2), i2.options.allowTraversingTree && (i2.eventsToUnbind.push(ty(i2, "click", i2.onClickDrillToNode)), i2.eventsToUnbind.push(ty(i2, "setRootNode", function(t11) {
            let e3 = i2.chart;
            e3.breadcrumbs && e3.breadcrumbs.updateProperties(i2.createList(t11));
          })), i2.eventsToUnbind.push(ty(i2, "update", function(t11, e3) {
            let i3 = this.chart.breadcrumbs;
            i3 && t11.options.breadcrumbs && i3.update(t11.options.breadcrumbs), this.hadOutsideDataLabels = this.hasOutsideDataLabels;
          })), i2.eventsToUnbind.push(ty(i2, "destroy", function(t11) {
            let e3 = this.chart;
            e3.breadcrumbs && !t11.keepEventsForUpdate && (e3.breadcrumbs.destroy(), e3.breadcrumbs = void 0);
          }))), t10.breadcrumbs || (t10.breadcrumbs = new N(t10, s2)), i2.eventsToUnbind.push(ty(t10.breadcrumbs, "up", function(t11) {
            let e3 = this.level - t11.newLevel;
            for (let t12 = 0; t12 < e3; t12++) i2.drillUp();
          }));
        }
        onClickDrillToNode(t10) {
          let e2 = t10.point, i2 = e2 == null ? void 0 : e2.drillId;
          tI(i2) && (e2.setState(""), this.setRootNode(i2, true, { trigger: "click" }));
        }
        pointAttribs(t10, e2) {
          let i2 = tB(this.mapOptionsToLevel) ? this.mapOptionsToLevel : {}, s2 = t10 && i2[t10.node.level] || {}, o2 = this.options, r2 = e2 && o2.states && o2.states[e2] || {}, a2 = (t10 == null ? void 0 : t10.getClassName()) || "", l2 = { stroke: t10 && t10.borderColor || s2.borderColor || r2.borderColor || o2.borderColor, "stroke-width": tD(t10 && t10.borderWidth, s2.borderWidth, r2.borderWidth, o2.borderWidth), dashstyle: (t10 == null ? void 0 : t10.borderDashStyle) || s2.borderDashStyle || r2.borderDashStyle || o2.borderDashStyle, fill: (t10 == null ? void 0 : t10.color) || this.color };
          return -1 !== a2.indexOf("highcharts-above-level") ? (l2.fill = "none", l2["stroke-width"] = 0) : -1 !== a2.indexOf("highcharts-internal-node-interactive") ? (l2["fill-opacity"] = r2.opacity ?? o2.opacity ?? 1, l2.cursor = "pointer") : -1 !== a2.indexOf("highcharts-internal-node") ? l2.fill = "none" : e2 && r2.brightness && (l2.fill = tu(l2.fill).brighten(r2.brightness).get()), l2;
        }
        setColorRecursive(t10, e2, i2, s2, o2) {
          var _a;
          let r2 = this == null ? void 0 : this.chart, a2 = (_a = r2 == null ? void 0 : r2.options) == null ? void 0 : _a.colors;
          if (t10) {
            let r3 = tb(t10, { colors: a2, index: s2, mapOptionsToLevel: this.mapOptionsToLevel, parentColor: e2, parentColorIndex: i2, series: this, siblings: o2 }), l2 = this.points[t10.i];
            l2 && (l2.color = r3.color, l2.colorIndex = r3.colorIndex);
            let n2 = -1;
            for (let e3 of t10.children || []) this.setColorRecursive(e3, r3.color, r3.colorIndex, ++n2, t10.children.length);
          }
        }
        setPointValues() {
          let t10 = this, { points: e2, xAxis: i2, yAxis: s2 } = t10, o2 = t10.chart.styledMode, r2 = (e3) => o2 ? 0 : t10.pointAttribs(e3)["stroke-width"] || 0;
          for (let t11 of e2) {
            let { pointValues: e3, visible: o3 } = t11.node;
            if (e3 && o3) {
              let { height: o4, width: a2, x: l2, y: n2 } = e3, h2 = r2(t11), d2 = i2.toPixels(l2, true), p2 = i2.toPixels(l2 + a2, true), u2 = s2.toPixels(n2, true), c2 = s2.toPixels(n2 + o4, true), g2 = 0 === d2 ? h2 / 2 : tw(i2.toPixels(l2, true), h2, true), v2 = p2 === i2.len ? i2.len - h2 / 2 : tw(i2.toPixels(l2 + a2, true), h2, true), f2 = u2 === s2.len ? s2.len - h2 / 2 : tw(s2.toPixels(n2, true), h2, true), b2 = 0 === c2 ? h2 / 2 : tw(s2.toPixels(n2 + o4, true), h2, true), m2 = { x: Math.min(g2, v2), y: Math.min(f2, b2), width: Math.abs(v2 - g2), height: Math.abs(b2 - f2) };
              t11.plotX = m2.x + m2.width / 2, t11.plotY = m2.y + m2.height / 2, t11.shapeArgs = m2;
            } else delete t11.plotX, delete t11.plotY;
          }
        }
        setRootNode(t10, e2, i2) {
          tO(this, "setRootNode", tS({ newRootId: t10, previousRootId: this.rootNode, redraw: tD(e2, true), series: this }, i2), function(t11) {
            let e3 = t11.series;
            e3.idPreviousRoot = t11.previousRootId, e3.rootNode = t11.newRootId, e3.isDirty = true, t11.redraw && e3.chart.redraw();
          });
        }
        setState(t10) {
          this.options.inactiveOtherPoints = true, super.setState(t10, false), this.options.inactiveOtherPoints = false;
        }
        setTreeValues(t10) {
          var _a, _b, _c;
          let e2 = this.options, i2 = this.rootNode, s2 = this.nodeMap[i2], o2 = "boolean" != typeof e2.levelIsConstant || e2.levelIsConstant, r2 = [], a2 = this.points[t10.i], l2 = 0;
          for (let e3 of t10.children) e3 = this.setTreeValues(e3), r2.push(e3), e3.ignore || (l2 += e3.val);
          tG(r2, (t11, e3) => (t11.sortIndex || 0) - (e3.sortIndex || 0));
          let n2 = tD(a2 == null ? void 0 : a2.simulatedValue, a2 == null ? void 0 : a2.options.value, l2);
          return a2 && (a2.value = n2), (a2 == null ? void 0 : a2.isGroup) && ((_a = e2.cluster) == null ? void 0 : _a.reductionFactor) && (n2 /= e2.cluster.reductionFactor), ((_c = (_b = t10.parentNode) == null ? void 0 : _b.point) == null ? void 0 : _c.isGroup) && this.rootNode !== t10.parent && (t10.visible = false), tS(t10, { children: r2, childrenTotal: l2, ignore: !(tD(a2 == null ? void 0 : a2.visible, true) && n2 > 0), isLeaf: t10.visible && !l2, isGroup: a2 == null ? void 0 : a2.isGroup, levelDynamic: t10.level - (o2 ? 0 : s2.level), name: tD(a2 == null ? void 0 : a2.name, ""), sortIndex: tD(a2 == null ? void 0 : a2.sortIndex, -n2), val: n2 }), t10;
        }
        sliceAndDice(t10, e2) {
          return this.algorithmFill(true, t10, e2);
        }
        squarified(t10, e2) {
          return this.algorithmLowAspectRatio(true, t10, e2);
        }
        strip(t10, e2) {
          return this.algorithmLowAspectRatio(false, t10, e2);
        }
        stripes(t10, e2) {
          return this.algorithmFill(false, t10, e2);
        }
        translate(t10) {
          var _a;
          let e2 = this, i2 = e2.options, s2 = !t10, o2 = tx(e2), r2, a2, l2, n2;
          t10 || o2.startsWith("highcharts-grouped-treemap-points-") || ((this.points || []).forEach((t11) => {
            t11.isGroup && t11.destroy();
          }), super.translate(), t10 = e2.getTree()), e2.tree = t10 = t10 || e2.tree, r2 = e2.nodeMap[o2], "" === o2 || r2 || (e2.setRootNode("", false), o2 = e2.rootNode, r2 = e2.nodeMap[o2]), ((_a = r2.point) == null ? void 0 : _a.isGroup) || (e2.mapOptionsToLevel = tm({ from: r2.level + 1, levels: i2.levels, to: t10.height, defaults: { levelIsConstant: e2.options.levelIsConstant, colorByPoint: i2.colorByPoint } })), ts.recursive(e2.nodeMap[e2.rootNode], (t11) => {
            let i3 = t11.parent, s3 = false;
            return t11.visible = true, (i3 || "" === i3) && (s3 = e2.nodeMap[i3]), s3;
          }), ts.recursive(e2.nodeMap[e2.rootNode].children, (t11) => {
            let e3 = false;
            for (let i3 of t11) i3.visible = true, i3.children.length && (e3 = (e3 || []).concat(i3.children));
            return e3;
          }), e2.setTreeValues(t10), e2.axisRatio = e2.xAxis.len / e2.yAxis.len, e2.nodeMap[""].pointValues = a2 = { x: 0, y: 0, width: 100, height: 100 }, e2.nodeMap[""].values = l2 = tN(a2, { width: a2.width * e2.axisRatio, direction: +("vertical" !== i2.layoutStartingDirection), val: t10.val }), (this.hasOutsideDataLabels || this.hadOutsideDataLabels) && this.drawDataLabels(), e2.calculateChildrenAreas(t10, l2), e2.colorAxis || i2.colorByPoint || e2.setColorRecursive(e2.tree), i2.allowTraversingTree && r2.pointValues && (n2 = r2.pointValues, e2.xAxis.setExtremes(n2.x, n2.x + n2.width, false), e2.yAxis.setExtremes(n2.y, n2.y + n2.height, false), e2.xAxis.setScale(), e2.yAxis.setScale()), e2.setPointValues(), s2 && e2.applyTreeGrouping();
        }
      }
      tz.defaultOptions = tN(tf.defaultOptions, ti), tS(tz.prototype, { buildKDTree: tg, colorAttribs: F.seriesMembers.colorAttribs, colorKey: "colorValue", directTouch: true, getExtremesFromAll: true, getSymbol: tg, optionalAxis: "colorAxis", parallelArrays: ["x", "y", "value", "colorValue"], pointArrayMap: ["value", "colorValue"], pointClass: tt, NodeClass: X, trackerGroups: ["group", "dataLabelsGroup"], utils: ts }), F.compose(tz), G().registerSeriesType("treemap", tz);
      let { deg2rad: tW } = g(), { fireEvent: tU, isNumber: tF, pick: t_, relativeLength: tY } = g();
      !function(t10) {
        t10.getCenter = function() {
          let t11 = this.options, e2 = this.chart, i2 = 2 * (t11.slicedOffset || 0), s2 = e2.plotWidth - 2 * i2, o2 = e2.plotHeight - 2 * i2, r2 = t11.center, a2 = Math.min(s2, o2), l2 = t11.thickness, n2, h2 = t11.size, d2 = t11.innerSize || 0, p2, u2;
          "string" == typeof h2 && (h2 = parseFloat(h2)), "string" == typeof d2 && (d2 = parseFloat(d2));
          let c2 = [t_(r2 == null ? void 0 : r2[0], "50%"), t_(r2 == null ? void 0 : r2[1], "50%"), t_(h2 && h2 < 0 ? void 0 : t11.size, "100%"), t_(d2 && d2 < 0 ? void 0 : t11.innerSize || 0, "0%")];
          for (!e2.angular || this instanceof Y() || (c2[3] = 0), p2 = 0; p2 < 4; ++p2) u2 = c2[p2], n2 = p2 < 2 || 2 === p2 && /%$/.test(u2), c2[p2] = tY(u2, [s2, o2, a2, c2[2]][p2]) + (n2 ? i2 : 0);
          return c2[3] > c2[2] && (c2[3] = c2[2]), tF(l2) && 2 * l2 < c2[2] && l2 > 0 && (c2[3] = c2[2] - 2 * l2), tU(this, "afterGetCenter", { positions: c2 }), c2;
        }, t10.getStartAndEndRadians = function(t11, e2) {
          let i2 = tF(t11) ? t11 : 0, s2 = tF(e2) && e2 > i2 && e2 - i2 < 360 ? e2 : i2 + 360;
          return { start: tW * (i2 + -90), end: tW * (s2 + -90) };
        };
      }(n || (n = {}));
      let tj = n, { series: { prototype: { pointClass: tX } }, seriesTypes: { treemap: { prototype: { pointClass: t$ } } } } = G(), { correctFloat: tK, extend: tq, pInt: tZ } = g();
      class tJ extends t$ {
        getDataLabelPath(t10) {
          var _a;
          let e2 = this.series.chart.renderer, i2 = this.shapeExisting, s2 = i2.r + tZ(((_a = t10.options) == null ? void 0 : _a.distance) || 0), o2 = i2.start, r2 = i2.end, a2 = o2 + (r2 - o2) / 2, l2 = a2 < 0 && a2 > -Math.PI || a2 > Math.PI, n2;
          return o2 === -Math.PI / 2 && tK(r2) === tK(1.5 * Math.PI) && (o2 = -Math.PI + Math.PI / 360, r2 = -Math.PI / 360, l2 = true), r2 - o2 > Math.PI && (l2 = false, n2 = true, r2 - o2 > 2 * Math.PI - 0.01 && (o2 += 0.01, r2 -= 0.01)), this.dataLabelPath && (this.dataLabelPath = this.dataLabelPath.destroy()), this.dataLabelPath = e2.arc({ open: true, longArc: +!!n2 }).attr({ start: l2 ? o2 : r2, end: l2 ? r2 : o2, clockwise: +l2, x: i2.x, y: i2.y, r: (s2 + i2.innerR) / 2 }).add(e2.defs), this.dataLabelPath;
        }
        isValid() {
          return true;
        }
      }
      tq(tJ.prototype, { getClassName: tX.prototype.getClassName, haloPath: tX.prototype.haloPath, setState: tX.prototype.setState });
      let { seriesTypes: { treemap: tQ } } = G(), { isNumber: t0, isObject: t1, merge: t2 } = g();
      function t6(t10, e2) {
        let i2 = [];
        if (t0(t10) && t0(e2) && t10 <= e2) for (let s2 = t10; s2 <= e2; s2++) i2.push(s2);
        return i2;
      }
      let t5 = { calculateLevelSizes: function(t10, e2) {
        let i2 = t1(e2) ? e2 : {}, s2, o2 = 0, r2, a2, l2, n2;
        if (t1(t10)) {
          for (let e3 of (s2 = t2({}, t10), a2 = t6(t0(i2.from) ? i2.from : 0, t0(i2.to) ? i2.to : 0), l2 = Object.keys(s2).filter((t11) => -1 === a2.indexOf(+t11)), r2 = n2 = t0(i2.diffRadius) ? i2.diffRadius : 0, a2)) {
            let t11 = s2[e3], i3 = t11.levelSize.unit, a3 = t11.levelSize.value;
            "weight" === i3 ? o2 += a3 : "percentage" === i3 ? (t11.levelSize = { unit: "pixels", value: a3 / 100 * r2 }, n2 -= t11.levelSize.value) : "pixels" === i3 && (n2 -= a3);
          }
          for (let t11 of a2) {
            let e3 = s2[t11];
            if ("weight" === e3.levelSize.unit) {
              let i3 = e3.levelSize.value;
              s2[t11].levelSize = { unit: "pixels", value: i3 / o2 * n2 };
            }
          }
          for (let t11 of l2) s2[t11].levelSize = { value: 0, unit: "pixels" };
        }
        return s2;
      }, getLevelFromAndTo: function({ level: t10, height: e2 }) {
        return { from: t10 > 0 ? t10 : 1, to: t10 + e2 };
      }, range: t6, recursive: tQ.prototype.utils.recursive }, { deg2rad: t9 } = g(), { addEvent: t3, merge: t8, uniqueKey: t4, defined: t7, extend: et } = g();
      function ee(t10, e2) {
        e2 = t8(true, { enabled: true, attributes: { dy: -5, startOffset: "50%", textAnchor: "middle" } }, e2);
        let i2 = this.renderer.url, s2 = this.text || this, o2 = s2.textPath, { attributes: r2, enabled: a2 } = e2;
        if (t10 = t10 || o2 && o2.path, o2 && o2.undo(), t10 && a2) {
          let e3 = t3(s2, "afterModifyTree", (e4) => {
            if (t10 && a2) {
              let o3 = t10.attr("id");
              o3 || t10.attr("id", o3 = t4());
              let a3 = { x: 0, y: 0 };
              t7(r2.dx) && (a3.dx = r2.dx, delete r2.dx), t7(r2.dy) && (a3.dy = r2.dy, delete r2.dy), s2.attr(a3), this.attr({ transform: "" }), this.box && (this.box = this.box.destroy());
              let l2 = e4.nodes.slice(0);
              e4.nodes.length = 0, e4.nodes[0] = { tagName: "textPath", attributes: et(r2, { "text-anchor": r2.textAnchor, href: `${i2}#${o3}` }), children: l2 };
            }
          });
          s2.textPath = { path: t10, undo: e3 };
        } else s2.attr({ dx: 0, dy: 0 }), delete s2.textPath;
        return this.added && (s2.textCache = "", this.renderer.buildText(s2)), this;
      }
      function ei(t10) {
        var _a;
        let e2 = t10.bBox, i2 = (_a = this.element) == null ? void 0 : _a.querySelector("textPath");
        if (i2) {
          let t11 = [], { b: s2, h: o2 } = this.renderer.fontMetrics(this.element), r2 = o2 - s2, a2 = RegExp('(<tspan>|<tspan(?!\\sclass="highcharts-br")[^>]*>|<\\/tspan>)', "g"), l2 = i2.innerHTML.replace(a2, "").split(/<tspan class="highcharts-br"[^>]*>/), n2 = l2.length, h2 = (t12, e3) => {
            let { x: o3, y: a3 } = e3, l3 = (i2.getRotationOfChar(t12) - 90) * t9, n3 = Math.cos(l3), h3 = Math.sin(l3);
            return [[o3 - r2 * n3, a3 - r2 * h3], [o3 + s2 * n3, a3 + s2 * h3]];
          };
          for (let e3 = 0, s3 = 0; s3 < n2; s3++) {
            let o3 = l2[s3].length;
            for (let r3 = 0; r3 < o3; r3 += 5) try {
              let o4 = e3 + r3 + s3, [a3, l3] = h2(o4, i2.getStartPositionOfChar(o4));
              0 === r3 ? (t11.push(l3), t11.push(a3)) : (0 === s3 && t11.unshift(l3), s3 === n2 - 1 && t11.push(a3));
            } catch {
              break;
            }
            e3 += o3 - 1;
            try {
              let o4 = e3 + s3, r3 = i2.getEndPositionOfChar(o4), [a3, l3] = h2(o4, r3);
              t11.unshift(l3), t11.unshift(a3);
            } catch {
              break;
            }
          }
          t11.length && t11.push(t11[0].slice()), e2.polygon = t11;
        }
        return e2;
      }
      function es(t10) {
        var _a;
        let e2 = t10.labelOptions, i2 = t10.point, s2 = e2[i2.formatPrefix + "TextPath"] || e2.textPath;
        s2 && !e2.useHTML && (this.setTextPath(((_a = i2.getDataLabelPath) == null ? void 0 : _a.call(i2, this)) || i2.graphic, s2), i2.dataLabelPath && !s2.enabled && (i2.dataLabelPath = i2.dataLabelPath.destroy()));
      }
      let { getCenter: eo, getStartAndEndRadians: er } = tj, { noop: ea } = g(), { column: el, treemap: en } = G().seriesTypes, { getColor: eh, getLevelOptions: ed, setTreeValues: ep, updateRootId: eu } = tp, { defined: ec, error: eg, extend: ev, fireEvent: ef, isNumber: eb, isObject: em, isString: ex, merge: ey, splat: eL } = g();
      ({ compose: function(t10) {
        t3(t10, "afterGetBBox", ei), t3(t10, "beforeAddingDataLabel", es);
        let e2 = t10.prototype;
        e2.setTextPath || (e2.setTextPath = ee);
      } }).compose(V());
      let eP = 180 / Math.PI, eT = function(t10, e2, i2, s2) {
        return { x: t10 + Math.cos(i2) * s2, y: e2 + Math.sin(i2) * s2 };
      };
      function ew(t10, e2) {
        let i2 = e2.mapIdToNode, s2 = t10.parent, o2 = s2 ? i2[s2] : void 0, r2 = e2.series, a2 = r2.chart, l2 = r2.points[t10.i], n2 = eh(t10, { colors: r2.options.colors || a2 && a2.options.colors, colorIndex: r2.colorIndex, index: e2.index, mapOptionsToLevel: e2.mapOptionsToLevel, parentColor: o2 && o2.color, parentColorIndex: o2 && o2.colorIndex, series: e2.series, siblings: e2.siblings });
        return t10.color = n2.color, t10.colorIndex = n2.colorIndex, l2 && (l2.color = t10.color, l2.colorIndex = t10.colorIndex, t10.sliced = t10.id !== e2.idRoot && l2.sliced), t10;
      }
      class eA extends en {
        alignDataLabel(t10, e2, i2) {
          if (!i2.textPath || !i2.textPath.enabled) return e2.placed = false, super.alignDataLabel.apply(this, arguments);
        }
        animate(t10) {
          let e2, i2 = this.chart, s2 = [i2.plotWidth / 2, i2.plotHeight / 2], o2 = i2.plotLeft, r2 = i2.plotTop, a2 = this.group;
          t10 ? (e2 = { translateX: s2[0] + o2, translateY: s2[1] + r2, scaleX: 1e-3, scaleY: 1e-3, rotation: 10, opacity: 0.01 }, a2.attr(e2)) : (e2 = { translateX: o2, translateY: r2, scaleX: 1, scaleY: 1, rotation: 0, opacity: 1 }, a2.animate(e2, this.options.animation));
        }
        drawPoints() {
          let t10 = this, e2 = t10.mapOptionsToLevel, i2 = t10.shapeRoot, s2 = t10.group, o2 = t10.hasRendered, r2 = t10.rootNode, a2 = t10.idPreviousRoot, l2 = t10.nodeMap, n2 = l2[a2], h2 = n2 && n2.shapeArgs, d2 = t10.points, p2 = t10.startAndEndRadians, u2 = t10.chart, c2 = u2 && u2.options && u2.options.chart || {}, g2 = "boolean" != typeof c2.animation || c2.animation, v2 = t10.center, f2 = { x: v2[0], y: v2[1] }, b2 = v2[3] / 2, m2 = t10.chart.renderer, x2 = !!(g2 && o2 && r2 !== a2 && t10.dataLabelsGroup), y2, L2 = false, P2 = false;
          for (let n3 of (x2 && (t10.dataLabelsGroup.attr({ opacity: 0 }), y2 = function() {
            L2 = true, t10.dataLabelsGroup && t10.dataLabelsGroup.animate({ opacity: 1, visibility: "inherit" });
          }), d2)) {
            let d3, c3, v3 = n3.node, x3 = e2[v3.level], L3 = n3.shapeExisting || {}, T2 = v3.shapeArgs || {}, w2 = !!(v3.visible && v3.shapeArgs);
            T2.borderRadius = t10.options.borderRadius, d3 = o2 && g2 ? function(t11, e3) {
              let i3 = e3.point, s3 = e3.radians, o3 = e3.innerR, r3 = e3.idRoot, a3 = e3.idPreviousRoot, l3 = e3.shapeExisting, n4 = e3.shapeRoot, h3 = e3.shapePreviousRoot, d4 = e3.visible, p3 = {}, u3 = { end: t11.end, start: t11.start, innerR: t11.innerR, r: t11.r, x: t11.x, y: t11.y };
              return d4 ? !i3.graphic && h3 && ((p3 = r3 === i3.id ? { start: s3.start, end: s3.end } : h3.end <= t11.start ? { start: s3.end, end: s3.end } : { start: s3.start, end: s3.start }).innerR = p3.r = o3) : i3.graphic && (a3 === i3.id ? u3 = { innerR: o3, r: o3 } : n4 && (u3 = n4.end <= l3.start ? { innerR: o3, r: o3, start: s3.end, end: s3.end } : { innerR: o3, r: o3, start: s3.start, end: s3.start })), { from: p3, to: u3 };
            }(T2, { center: f2, point: n3, radians: p2, innerR: b2, idRoot: r2, idPreviousRoot: a2, shapeExisting: L3, shapeRoot: i2, shapePreviousRoot: h2, visible: w2 }) : { to: T2, from: {} }, ev(n3, { shapeExisting: T2, tooltipPos: [T2.plotX, T2.plotY], drillId: function(t11, e3, i3) {
              let s3;
              return t11.node.isLeaf || (s3 = e3 === t11.id ? i3[e3].parent : t11.id), s3;
            }(n3, r2, l2), name: "" + (n3.name || n3.id || n3.index), plotX: T2.plotX, plotY: T2.plotY, value: v3.val, isInside: w2, isNull: !w2 }), n3.dlOptions = function(t11) {
              var _a, _b, _c;
              let e3 = t11.point, i3 = em(t11.shapeArgs) ? t11.shapeArgs : {}, { end: s3 = 0, radius: o3 = 0, start: r3 = 0 } = i3, a3 = em(t11.optionsPoint) ? t11.optionsPoint.dataLabels : {}, l3 = ey(eL(em(t11.level) ? t11.level.dataLabels : {})[0], a3), n4 = l3.style = l3.style || {}, { innerArcLength: h3 = 0, outerArcLength: d4 = 0 } = e3, p3, u3, c4 = l3.rotationMode, g3 = ec(n4.width) ? parseInt(n4.width || "0", 10) : void 0;
              return eb(l3.rotation) || (("auto" === c4 || "circular" === c4) && (l3.useHTML && "circular" === c4 && (c4 = "auto"), h3 < 1 && d4 > o3 ? (p3 = 0, e3.dataLabelPath && "circular" === c4 && (l3.textPath = { enabled: true }), s3 - r3 < Math.PI && (g3 = 0.7 * o3)) : h3 > 1 && d4 > 1.5 * o3 ? "circular" === c4 ? l3.textPath = { enabled: true, attributes: { dy: 5 } } : c4 = "parallel" : (((_a = e3.dataLabel) == null ? void 0 : _a.textPath) && "circular" === c4 && (l3.textPath = { enabled: false }), c4 = "perpendicular")), "auto" !== c4 && "circular" !== c4 && (((_b = e3.dataLabel) == null ? void 0 : _b.textPath) && (l3.textPath = { enabled: false }), p3 = s3 - (s3 - r3) / 2), "parallel" === c4 ? g3 = Math.min(2.5 * o3, (d4 + h3) / 2) : !ec(g3) && o3 && (g3 = 1 === e3.node.level ? 2 * o3 : o3), "perpendicular" === c4 && (d4 < 16 ? g3 = 1 : i3.radius && (n4.lineClamp = Math.floor(h3 / 16) || 1, g3 = o3 - (h3 < 16 ? (16 - h3) / (d4 - h3) * o3 : 0))), g3 = Math.max((g3 || 0) - 2 * (l3.padding || 0), 1), u3 = (p3 || 0) * eP % 180, "parallel" === c4 && (u3 -= 90), u3 > 90 ? u3 -= 180 : u3 < -90 && (u3 += 180), l3.rotation = u3), l3.textPath && (0 === e3.shapeExisting.innerR && l3.textPath.enabled ? (l3.rotation = 0, l3.textPath.enabled = false, g3 = Math.max(2 * e3.shapeExisting.r - 2 * (l3.padding || 0), 1)) : ((_c = e3.dlOptions) == null ? void 0 : _c.textPath) && !e3.dlOptions.textPath.enabled && "circular" === c4 && (l3.textPath.enabled = true), l3.textPath.enabled && (l3.rotation = 0, g3 = Math.max((d4 + h3) / 2 - 2 * (l3.padding || 0), 1), n4.whiteSpace = "nowrap")), n4.width = g3 + "px", l3;
            }({ point: n3, level: x3, optionsPoint: n3.options, shapeArgs: T2 }), !P2 && w2 && (P2 = true, c3 = y2), n3.draw({ animatableAttribs: d3.to, attribs: ev(d3.from, !u2.styledMode && t10.pointAttribs(n3, n3.selected && "select")), onComplete: c3, group: s2, renderer: m2, shapeType: "arc", shapeArgs: T2 });
          }
          x2 && P2 ? (t10.hasRendered = false, t10.options.dataLabels.defer = true, el.prototype.drawDataLabels.call(t10), t10.hasRendered = true, L2 && y2()) : el.prototype.drawDataLabels.call(t10), t10.idPreviousRoot = r2;
        }
        layoutAlgorithm(t10, e2, i2) {
          let s2 = t10.start, o2 = t10.end - s2, r2 = t10.val, a2 = t10.x, l2 = t10.y, n2 = i2 && em(i2.levelSize) && eb(i2.levelSize.value) ? i2.levelSize.value : 0, h2 = t10.r, d2 = h2 + n2, p2 = i2 && eb(i2.slicedOffset) ? i2.slicedOffset : 0;
          return (e2 || []).reduce((t11, e3) => {
            let i3 = 1 / r2 * e3.val * o2, u2 = eT(a2, l2, s2 + i3 / 2, p2), c2 = { x: e3.sliced ? u2.x : a2, y: e3.sliced ? u2.y : l2, innerR: h2, r: d2, radius: n2, start: s2, end: s2 + i3 };
            return t11.push(c2), s2 = c2.end, t11;
          }, []);
        }
        setRootNode(t10, e2, i2) {
          if (1 === this.nodeMap[t10].level && 1 === this.nodeList.filter((t11) => 1 === t11.level).length) {
            if ("" === this.idPreviousRoot) return;
            t10 = "";
          }
          super.setRootNode(t10, e2, i2);
        }
        setShapeArgs(t10, e2, i2) {
          let s2 = i2[t10.level + 1], o2 = t10.children.filter(function(t11) {
            return t11.visible;
          }), r2 = [];
          r2 = this.layoutAlgorithm(e2, o2, s2);
          let a2 = -1;
          for (let t11 of o2) {
            let e3 = r2[++a2], s3 = e3.start + (e3.end - e3.start) / 2, o3 = e3.innerR + (e3.r - e3.innerR) / 2, l2 = e3.end - e3.start, n2 = 0 === e3.innerR && l2 > 6.28 ? { x: e3.x, y: e3.y } : eT(e3.x, e3.y, s3, o3), h2 = t11.val ? t11.childrenTotal > t11.val ? t11.childrenTotal : t11.val : t11.childrenTotal;
            this.points[t11.i] && (this.points[t11.i].innerArcLength = l2 * e3.innerR, this.points[t11.i].outerArcLength = l2 * e3.r), t11.shapeArgs = ey(e3, { plotX: n2.x, plotY: n2.y }), t11.values = ey(e3, { val: h2 }), t11.children.length && this.setShapeArgs(t11, t11.values, i2);
          }
        }
        translate() {
          let t10 = this.options, e2 = this.center = this.getCenter(), i2 = this.startAndEndRadians = er(t10.startAngle, t10.endAngle), s2 = e2[3] / 2, o2 = e2[2] / 2, r2 = eu(this), a2 = this.nodeMap, l2, n2 = a2 && a2[r2], h2 = {};
          this.shapeRoot = n2 && n2.shapeArgs, this.generatePoints(), ef(this, "afterTranslate");
          let d2 = this.tree = this.getTree(), p2 = ex((n2 = (a2 = this.nodeMap)[r2]).parent) ? n2.parent : "", u2 = a2[p2], { from: c2, to: g2 } = t5.getLevelFromAndTo(n2);
          l2 = ed({ from: c2, levels: this.options.levels, to: g2, defaults: { colorByPoint: t10.colorByPoint, dataLabels: t10.dataLabels, levelIsConstant: t10.levelIsConstant, levelSize: t10.levelSize, slicedOffset: t10.slicedOffset } }), l2 = t5.calculateLevelSizes(l2, { diffRadius: o2 - s2, from: c2, to: g2 }), ep(d2, { before: ew, idRoot: r2, levelIsConstant: t10.levelIsConstant, mapOptionsToLevel: l2, mapIdToNode: a2, points: this.points, series: this });
          let v2 = a2[""].shapeArgs = { end: i2.end, r: s2, start: i2.start, val: n2.val, x: e2[0], y: e2[1] };
          for (let t11 of (this.setShapeArgs(u2, v2, l2), this.mapOptionsToLevel = l2, this.points)) h2[t11.id] && eg(31, false, this.chart), h2[t11.id] = true;
        }
      }
      eA.defaultOptions = ey(en.defaultOptions, { center: ["50%", "50%"], clip: false, colorByPoint: false, opacity: 1, dataLabels: { allowOverlap: true, defer: true, rotationMode: "circular", style: { textOverflow: "ellipsis" } }, rootId: void 0, levelIsConstant: true, levelSize: { value: 1, unit: "weight" }, slicedOffset: 10 }), ev(eA.prototype, { axisTypes: [], drawDataLabels: ea, getCenter: eo, isCartesian: false, onPointSupported: true, pointAttribs: el.prototype.pointAttribs, pointClass: tJ, NodeClass: class extends X {
      }, utils: t5 }), G().registerSeriesType("sunburst", eA);
      let eR = g();
      eR.Breadcrumbs = eR.Breadcrumbs || N, eR.Breadcrumbs.compose(eR.Chart, eR.defaultOptions);
      let eS = g();
      return u.default;
    })());
  }
});
export default require_sunburst();
//# sourceMappingURL=highcharts_modules_sunburst.js.map
